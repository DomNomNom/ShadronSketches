#version 330

#include <shapes>
#include <math_constants>


const float max_speed = 8;
const float max_torque = 2.;

// Speed of the simulation (steps per second)
param float FPS = 80.0 : hidden;//logrange(1.0, 1024.0);

param float theta_render_shift = PI : range(0, .5);

// State layout:
// x - theta     // clockwise with 0=upright.
// y - theta_dot
// z - torque
// w - cost
float encode_theta(float theta) { return (theta+PI) / TAU +theta_render_shift; }
float decode_theta(float theta) { return ((theta-theta_render_shift)*TAU) - PI; }
float encode_theta_dot(float theta_dot) { return (theta_dot+max_speed) / (2*max_speed); }
float decode_theta_dot(float theta_dot) { return (theta_dot*(2*max_speed)) - max_speed; }
float encode_torque(float torque) { return (torque+max_torque) / (2*max_torque); }
float decode_torque(float torque) { return (torque*(2*max_torque)) - max_torque; }
float encode_cost(float cost) { return cost+1; }
float decode_cost(float cost) { return cost-1; }

var vec2 render_initial_pos = vec2(.25, .5);

event mouse_press(left_button, vec2 mousePos) {
    render_initial_pos = mousePos;
}
event mouse_position(left_button, vec2 mousePos) {
    render_initial_pos = mousePos;
}

// ============== Simulation

vec4 initial_state(vec2 pos) {
    return vec4(
        pos,
        encode_torque(0),
        encode_cost(0)
    );
}
image InitialState = glsl(initial_state, 512, 512);

vec4 initialize(vec2 pos) {
    return texture(InitialState, pos);
}

float policy(float theta, float theta_dot) {
    // return 0;
    return -10.0 * theta + -1 * theta_dot;
    // return -max_torque;
    // if (abs(theta) < .1) return -8*theta;
    // return -80. * theta;
}

float angle_normalize(float x) {  // Returns angle x but within -pi .. pi
    x = mod(x, TAU);
    x = (x < 0)? x+TAU : x; // if (x < 0) {  x += TAU;  }
    x = (x <= PI)? x : x - TAU;
    return x;
}

float square(float x) {
    return x*x;
}



vec4 simulation(sampler2D self, vec2 pos) {
    float dt = .05;
    float g = 10;
    float m = 1;
    float l = 1;

    vec4 prev = texture(self, pos);
    float theta = decode_theta(prev.x);
    float theta_dot = decode_theta_dot(prev.y);
    float prev_cost = decode_cost(prev.w);

    float torque = policy(theta, theta_dot);
    torque = clamp(torque, -max_torque, max_torque);
    float cost = square(angle_normalize(theta)) + .1 * square(theta_dot) + .001 * square(torque);

    float newthdot = theta_dot + (-3 * g / (2 * l) * sin(theta + PI) + 3. / (m * square(l)) * torque) * dt;
    float newth = theta + newthdot * dt;
    newthdot = clamp(newthdot, -max_speed, max_speed);

    theta = angle_normalize(newth);
    theta_dot = newthdot;

    cost = mix(prev_cost, cost, .01);
    return vec4(
        encode_theta(theta),
        encode_theta_dot(theta_dot),
        encode_torque(torque),
        encode_cost(cost)
    );
}


// =========== Rendering ===========


float inside(float signed_distance) {
    return smoothstep(0, 0.0001, signed_distance);
}

vec4 blend(inout vec4 buffer, in vec4 overlay) {
    buffer = vec4(mix(buffer.rgb, overlay.rgb, overlay.a), min(1, overlay.a+buffer.a));
    return buffer;
}

vec4 render_pendulum(vec2 pos, float theta) {
    vec4 col = vec4(0);
    vec2 tip = vec2(-sin(theta), cos(theta));
    col = mix(col, vec4(.7,0,0,1), inside(lineDistance(pos, vec2(0,0), tip, .2)));
    col = mix(col, vec4(0,0,0,1), inside(circleDistance(pos, vec2(0,0), .04)));
    return col;
}

float ring_distance(vec2 pos, float r, float half_width) {
    return half_width-abs(r-length(pos));
}

vec4 render_torque(vec2 pos, float torque) {  // torque acepts -1..1
    pos.x *= torque < 0? -1 : 1;
    torque = abs(torque);

    vec4 col = vec4(0);
    float r = .8;
    float half_width = .05;
    float d = ring_distance(pos, r, half_width);
    float head = torque / max_torque * PI * .8;  // angle of the tip
    float tail = head - .8;
    vec2 tip_head = (r-half_width) * vec2(-sin(head), cos(head));
    // vec2 tip_tail = (r+half_width) * vec2(-sin(tail), cos(tail));
    vec2 tip_tail = tip_head + vec2(-sin(head-PI/2), cos(head-PI/2));


    d = min(d, halfPlaneDistance(pos, vec2(0), vec2(0,1)));
    d = min(d, halfPlaneDistance(pos, vec2(0), -tip_head));
    d = min(d, halfPlaneDistance(pos, tip_tail, tip_head));

    col = mix(col, vec4(.4, .4, .4, 1), inside(d));
    // col = mix(col, vec4(.8, .8, .8, 1), .5*inside(halfPlaneDistance(pos, tip_tail, tip_head)));
    return col;
}

vec4 render_initial_pos_indicator(vec2 pos) {
    float should_draw_indicator = (
        float(pos.x == render_initial_pos.x) +
        float(pos.y == render_initial_pos.y)
    );
    return vec4(vec3(.1), .4*mod(should_draw_indicator,2));
}

vec3 heat_color(float x) {
    return 1-exp2(-vec3(10.*x, x, .1*x));
}

feedback Simulation, SimulationRender, RewardRender, PendulumImage {
    Simulation = glsl(simulation, sizeof(InitialState)) : initialize(initialize), full_range(true) , hidden;

    vec4 simulation_render(vec2 pos) {
        vec4 sim = texture(Simulation, pos);
        sim.x -= theta_render_shift;
        return blend(sim, render_initial_pos_indicator(pos));
    }
    SimulationRender = glsl(simulation_render, sizeof(Simulation)) : initialize(initialize);

    vec4 reward_render(vec2 pos) {
        vec4 sim = texture(Simulation, pos);
        float r = sim.w;
        vec4 col = vec4(heat_color(.1*r), 1);
        return blend(col, render_initial_pos_indicator(pos));
    }
    RewardRender = glsl(reward_render, sizeof(Simulation)) : initialize(initialize);

    vec4 pendulum_and_torque(vec2 pos) {
        vec4 sim = texture(Simulation, vec2(
            render_initial_pos
            // encode_theta(render_initial_theta),
            // encode_theta_dot(render_initial_theta_dot)
        ));
        float theta = decode_theta(sim.x);
        float torque = decode_torque(sim.z);

        pos = (pos-.5) * 2.8;
        vec4 col = render_pendulum(pos, theta);
        blend(col, render_torque(pos, torque));
        return col;
    }
    PendulumImage = glsl(pendulum_and_torque, 512, 512) : initialize(initialize);
} : update_rate(FPS), filter(nearest);



