#version 330
// #extension GL_ARB_gpu_shader_fp64

#include <shapes>
#include <math_constants>


parameter float p_torque = .5 : range(-1, 1);

const float max_speed = 8;
const float max_torque = 2.;



// Speed of the simulation (steps per second)
param float simulation_speed = 30.0 : logrange(1.0, 1024.0);


// State layout:
// x - theta     // clockwise with 0=upright.
// y - theta_dot
// z - torque
// w - cost
float encode_theta(float theta) { return (theta+PI) / TAU; }
float decode_theta(float theta) { return (theta*TAU) - PI; }
float encode_theta_dot(float theta_dot) { return (theta_dot+max_speed) / (2*max_speed); }
float decode_theta_dot(float theta_dot) { return (theta_dot*(2*max_speed)) - max_speed; }
float encode_torque(float torque) { return (torque+max_torque) / (2*max_torque); }
float decode_torque(float torque) { return (torque*(2*max_torque)) - max_torque; }
float encode_cost(float cost) { return cost+1; }
float decode_cost(float cost) { return cost-1; }

param float render_initial_theta = TAU/4 : range(decode_theta(0), decode_theta(1));
param float render_initial_theta_dot = 0 : range(decode_theta_dot(0), decode_theta_dot(1));

vec4 initial_state(vec2 pos) {
    return vec4(pos, encode_torque(0), encode_cost(0));
}
image InitialState = glsl(initial_state, 512, 512);

vec4 initialize(vec2 pos) {
    return texture(InitialState, pos);
}

float policy(float theta, float theta_dot) {
    return 0;
    // return -80. * theta + 0* theta_dot;
    // return -max_torque;
    if (abs(theta) < .1) return -8*theta;
    return -80. * theta;
}

float angle_normalize(float x) {  // Returns angle x but within -pi .. pi
    x = mod(x, TAU);
    x = (x < 0)? x+TAU : x; // if (x < 0) {  x += TAU;  }
    x = (x <= PI)? x : x - TAU;
    return x;
}

float square(float x) {
    return x*x;
}

vec4 simulation(sampler2D self, vec2 pos) {
    float dt = .08;
    float g = 10;
    float m = 1;
    float l = 1;

    vec4 prev = texture(self, pos);
    float theta = decode_theta(prev.x);
    float theta_dot = decode_theta_dot(prev.y);

    float torque = policy(theta, theta_dot);
    torque = clamp(torque, -max_torque, max_torque);
    float cost = square(angle_normalize(theta)) + .1 * square(theta_dot) + .001 * square(torque);

    float newthdot = theta_dot + (-3 * g / (2 * l) * sin(theta + PI) + 3. / (m * square(l)) * torque) * dt;
    float newth = theta + newthdot * dt;
    newthdot = clamp(newthdot, -max_speed, max_speed);

    theta = angle_normalize(newth);
    theta_dot = newthdot;

    cost = 1;
    // theta = PI;
    // theta_dot = 0;
    return vec4(
        encode_theta(theta),
        encode_theta_dot(theta_dot),
        encode_torque(torque),
        encode_cost(cost)
    );
}

// feedback Simulation = glsl(simulation, sizeof(InitialState)) : initialize(initialize), update_rate(simulation_speed), filter(nearest);

// =========== Rendering ===========


float inside(float signed_distance) {
    return smoothstep(0, 0.0001, signed_distance);
}

vec4 blend(inout vec4 buffer, in vec4 overlay) {
    buffer = vec4(mix(buffer.rgb, overlay.rgb, overlay.a), min(1, overlay.a+buffer.a));
    return buffer;
}

vec4 render_pendulum(vec2 pos, float theta) {
    vec4 col = vec4(0);
    vec2 tip = vec2(-sin(theta), cos(theta));
    col = mix(col, vec4(.7,0,0,1), inside(lineDistance(pos, vec2(0,0), tip, .2)));
    col = mix(col, vec4(0,0,0,1), inside(circleDistance(pos, vec2(0,0), .04)));
    return col;
}

float ring_distance(vec2 pos, float r, float half_width) {
    return half_width-abs(r-length(pos));
}

vec4 render_torque(vec2 pos, float torque) {  // torque acepts -1..1
    pos.x *= torque < 0? -1 : 1;
    torque = abs(torque);

    vec4 col = vec4(0);
    float r = .8;
    float half_width = .05;
    float d = ring_distance(pos, r, half_width);
    float head = torque / max_torque * PI * .8;  // angle of the tip
    float tail = head - .8;
    vec2 tip_head = (r-half_width) * vec2(-sin(head), cos(head));
    // vec2 tip_tail = (r+half_width) * vec2(-sin(tail), cos(tail));
    vec2 tip_tail = tip_head + vec2(-sin(head-PI/2), cos(head-PI/2));


    d = min(d, halfPlaneDistance(pos, vec2(0), vec2(0,1)));
    d = min(d, halfPlaneDistance(pos, vec2(0), -tip_head));
    d = min(d, halfPlaneDistance(pos, tip_tail, tip_head));

    col = mix(col, vec4(.4, .4, .4, 1), inside(d));
    // col = mix(col, vec4(.8, .8, .8, 1), .5*inside(halfPlaneDistance(pos, tip_tail, tip_head)));
    return col;
}

feedback Simulation, PendulumImage {
    Simulation = glsl(simulation, sizeof(InitialState)) : initialize(initialize), full_range(true);

    vec4 pendulum_and_torque(vec2 pos) {
        vec4 sim = texture(Simulation, vec2(
            encode_theta(render_initial_theta),
            encode_theta_dot(render_initial_theta_dot)
        ));
        float theta = decode_theta(sim.x);
        float torque = decode_torque(sim.z);

        pos = (pos-.5) * 2.8;
        vec4 col = render_pendulum(pos, theta);
        blend(col, render_torque(pos, torque));
        return col;
    }
    PendulumImage = glsl(pendulum_and_torque, 512, 512) : initialize(initialize);
} : update_rate(simulation_speed), filter(nearest);



