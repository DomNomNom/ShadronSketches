#include <shapes>
#include <math_constants>

parameter float p_torque = .5 : range(-1, 1);



// Speed of the simulation (steps per second)
param float simulation_speed = 30.0 : logrange(1.0, 1024.0);


// State layout:
// x - theta
// y - theta_dot
// z - torque
// w - cost

vec4 initial_state(vec2 pos) {
    pos = (pos - .5) * 2;

    return vec4(pos, 0, 1);
}
image InitialState = glsl(initial_state, 512, 512);

vec4 initialize(vec2 pos) {
    return texture(InitialState, pos);
}

float policy(float theta, float theta_dot) {
    return 0;
}

float angle_normalize(float x) {  // Returns x but within -pi .. pi
    x = mod(x, TAU);
    if (x < 0) {
        x += TAU;
    }
    x = (x <= PI)? x : x - TAU;
    return x;
}

float square(float x) {
    return x*x;
}

vec4 simulation(sampler2D self, vec2 pos) {
    float max_speed = 8;
    float max_torque = 2.;
    float dt = .08;
    float g = 10;
    float m = 1;
    float l = 1;
    float last_torque = 0;

    vec4 prev = texture(self, pos);
    float theta = prev.x;
    float theta_dot = prev.y;

    float torque = policy(theta, theta_dot);
    torque = clamp(torque, -max_torque, max_torque);
    last_torque = torque;
    float cost = square(angle_normalize(theta)) + .1 * square(theta_dot) + .001 * square(torque);

    float newthdot = theta_dot + (-3 * g / (2 * l) * sin(theta + PI) + 3. / (m * square(l)) * torque) * dt;
    float newth = theta + newthdot * dt;
    newthdot = clamp(newthdot, -max_speed, max_speed);

    theta = angle_normalize(newth);
    theta_dot = newthdot;

    cost = 1;
    return vec4(theta, theta_dot, torque, cost);
}

// feedback Simulation = glsl(simulation, sizeof(InitialState)) : initialize(initialize), update_rate(simulation_speed), filter(nearest);

// =========== Rendering ===========


float inside(float signed_distance) {
    return smoothstep(0, 0.0001, signed_distance);
}

vec4 blend(inout vec4 buffer, in vec4 overlay) {
    buffer = vec4(mix(buffer.rgb, overlay.rgb, overlay.a), min(1, overlay.a+buffer.a));
    return buffer;
}

vec4 render_pendulum(vec2 pos, float theta) {
    vec4 col = vec4(0);
    vec2 tip = vec2(-sin(theta), cos(theta));
    col = mix(col, vec4(.7,0,0,1), inside(lineDistance(pos, vec2(0,0), tip, .2)));
    col = mix(col, vec4(0,0,0,1), inside(circleDistance(pos, vec2(0,0), .04)));
    return col;
}

float ring_distance(vec2 pos, float r, float half_width) {
    return half_width-abs(r-length(pos));
}

vec4 render_torque(vec2 pos, float torque) {  // torque acepts -1..1
    pos.x *= torque < 0? -1 : 1;
    torque = abs(torque);

    vec4 col = vec4(0);
    float r = .8;
    float half_width = .05;
    float d = ring_distance(pos, r, half_width);
    float theta_head = torque * PI * .8;
    float theta_tail = theta_head - .8;
    vec2 tip_head = (r-half_width) * vec2(-sin(theta_head), cos(theta_head));
    // vec2 tip_tail = (r+half_width) * vec2(-sin(theta_tail), cos(theta_tail));
    vec2 tip_tail = tip_head + vec2(-sin(theta_head-PI/2), cos(theta_head-PI/2));


    d = min(d, halfPlaneDistance(pos, vec2(0), vec2(0,1)));
    d = min(d, halfPlaneDistance(pos, vec2(0), -tip_head));
    d = min(d, halfPlaneDistance(pos, tip_tail, tip_head));

    col = mix(col, vec4(.4, .4, .4, 1), inside(d));
    // col = mix(col, vec4(.8, .8, .8, 1), .5*inside(halfPlaneDistance(pos, tip_tail, tip_head)));
    return col;
}

feedback Simulation, PendulumImage {
    Simulation = glsl(simulation, sizeof(InitialState)) : initialize(initialize);

    vec4 pendulum_and_torque(vec2 pos) {
        vec4 sim = texture(Simulation, vec2(.5, .6));
        float theta = sim.x;
        float torque = sim.z;

        pos = (pos-.5) * 2.8;
        vec4 col = render_pendulum(pos, theta);
        blend(col, render_torque(pos, torque));
        // return vec4(pos,0,1);
        return col;
    }

    PendulumImage = glsl(pendulum_and_torque, 512, 512) : initialize(initialize);
} : update_rate(simulation_speed), filter(nearest);



