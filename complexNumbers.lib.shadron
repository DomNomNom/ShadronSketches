#include <math_constants>

glsl {

vec2 complex_multiply(vec2 z, vec2 w) {
    return vec2(
        z.x*w.x - z.y*w.y,
        z.x*w.y + z.y*w.x
    );
}

// computes a^z where only z is complex
vec2 real_pow_complex(float a, vec2 z) {
    return pow(a, z.x) * vec2(
        cos(z.y * log(a)),
        sin(z.y * log(a))
    );
}

// http://mathworld.wolfram.com/ComplexArgument.html
float complex_arg(vec2 z) {
    return atan(z.y, z.x);
}

// computes z^w where both are complex
// http://mathworld.wolfram.com/ComplexExponentiation.html
vec2 complex_pow_complex(vec2 z, vec2 w) {
    return complex_multiply(
        real_pow_complex(
            z.x*z.x + z.y*z.y,
            0.5 * w
        ),
        real_pow_complex(
            EULER,
            complex_multiply(vec2(0,1), w) * complex_arg(z)
        )
    );
}

}
