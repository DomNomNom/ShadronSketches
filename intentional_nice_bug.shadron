#version 330

#include <hsv.shadron>
#include <debug.shadron>
#include "library/complexNumbers.shadron"
#include "library/murmurHash.shadron"

#define PLANET_COUNT 10
#define UNIVERSE_COUNT 100

#define FPS 144.0
#define TIMESTEP (1./FPS)

param int universe_select : range(0, UNIVERSE_COUNT-1);
param float temperature = .1 : logrange(1e-15, 10);

param float weight_overlap = 1000 : logrange(1e-5, 1e5);
param float weight_apogee = 10 : logrange(1e-5, 1e5);
param float weight_radius = 1 : logrange(1e-5, 1e5);
param float weight_ecentricity = 10 : logrange(1e-5, 1e5);


glsl vec3 orange = vec3(1,.5,.0);
glsl vec3 lime = vec3(.5,1,.0);
glsl vec3 white = vec3(1,1,1);
glsl vec3 red = vec3(1,.1,.0);

struct Planet {
    vec2 a;
    vec2 b;
    float r;
};
vec2 planet_pos(Planet p, float time) {
    return cmul(p.a, ei(time)) + cmul(p.b, ei(-time));
}
float planet_stencil(Planet p, vec2 pos, float time) {
    vec2 ppos = planet_pos(p, time);
    const float boundary_size = .002;
    return smoothstep(boundary_size, -boundary_size, length(pos - ppos) - p.r);
}

Planet planet_orthoginalize(Planet p) {
    float arg_a = complex_arg(p.a);
    float arg_b = complex_arg(p.b);
    float average = (arg_a + arg_b)/2;
    return Planet(
        complex_rotate(p.a, -average),
        complex_rotate(p.b, -average),
        p.r
    );
}
Planet planet_unphase(Planet p) {
    return Planet(
        complex_rotate(p.a, -complex_arg(p.a)),
        complex_rotate(p.b, -complex_arg(p.b)),
        p.r
    );
}
Planet planet_standardize(Planet p) {
    return Planet(
        vec2(length(p.a), 0),
        vec2(length(p.b), 0),
        p.r
    );
}
vec2 planet_major_minor_lengths(Planet p) {
    float a = length(p.a);  // The unrotated and unphased versions of `a`
    float b = length(p.b);  // and `b` are purely real and preserve length.
    return vec2(a+b, a-b);  // What we evaluate to at t=0 and t=TAU/4
}

vec3 exposure(vec3 col) {
    return vec3(1) - pow(vec3(2), -1.8 * col);
}

float is_overlap_time(Planet p1, Planet p2, float time) {
    Planet p = Planet(p1.a - p2.a, p1.b - p2.b, p1.r + p2.r);
    float a = length(p.a);  // The unrotated and unphased versions of `a`
    float b = length(p.b);  // and `b` are purely real and preserve length.
    if (a*b <= 1e-15) return float(max(a,b) < p.r);
    float determinant = (p.r*p.r - a*a -b*b) / (2*a*b);
    if (determinant < -1) return 0;
    if (determinant > 1) return 1;
    float critical_angle = .5 * acos(determinant);
    time += (complex_arg(p.a) - complex_arg(p.b))/2;  // start caring about relative phases again.
    time = mod(time,PI);
    if (time > TAU / 4) time = PI - time;
    if (time - critical_angle > 0) return 1;
    return 0;
}

float overlap_fraction(Planet p1, Planet p2) {
    float a = length(p1.a - p2.a);  // The unrotated and unphased versions of `a`
    float b = length(p1.b - p2.b);  // and `b` are purely real and preserve length.
    float r = p1.r + p2.r;
    if (min(a,b) <= 1e-15) return float(max(a,b) < r);
    float determinant = (r*r - a*a -b*b) / (2*a*b);
    if (determinant <= -1) return 0;
    if (determinant >= 1) return 1;
    float critical_angle = .5 * acos(determinant);
    return 1 - (critical_angle / (TAU/4));
}
float[PLANET_COUNT] get_total_overlaps(Planet[PLANET_COUNT] planets) {
    float[PLANET_COUNT] total_overlaps;
    for (int i=0; i<PLANET_COUNT; ++i) {
        total_overlaps[i] = 0;
    }
    for (int i=0; i<PLANET_COUNT; ++i) {
        for (int j=i+1; j<PLANET_COUNT; ++j) {
            float overlap = overlap_fraction(planets[i], planets[j]);
            total_overlaps[i] += overlap;
            total_overlaps[j] += overlap;
        }
    }
    return total_overlaps;
}

float cauchy_sample_1(float random_zero_to_one, float median, float scale) {
    return median + scale * tan(PI*(random_zero_to_one-0.5));
}
vec4 cauchy_sample_4(vec4 random_zero_to_one, vec4 median, float scale) {
    return median + scale * tan(PI*(random_zero_to_one-0.5));
}
vec4 gaussian_sample_1(vec2 random_zero_to_one) {
    // This is a bit unusual to take two arguments for one random number.
    // https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform
    return sqrt(-2.0 * log(max(1e-15, random_zero_to_one.x))) * sin(2.0 * PI * random_zero_to_one.y);
}
vec2 gaussian_sample_2(vec2 random_zero_to_one) {
    // https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform
    return sqrt(-2.0 * log(random_zero_to_one.x + 1e-15)) * vec2(
        sin(2.0 * PI * random_zero_to_one.y),
        cos(2.0 * PI * random_zero_to_one.y)
    );
}
vec4 gaussian_sample_4(vec4 random_zero_to_one) {
    return vec4(
        gaussian_sample_2(random_zero_to_one.xy),
        gaussian_sample_2(random_zero_to_one.zw)
    );
}


vec4 gaussian_pixel(ivec2 pos, float time) {
    vec4 gaussian4 = gaussian_sample_4(hash34(vec3(time, pos)));
    if (pos.y >= PLANET_COUNT) gaussian4 *= vec4(1, 0, 0, 0); // we only take one random variable per planet size pixel.
    return gaussian4;
}
float rng_scale_implementation(int universe, float time) {
    // So we want to do the following thing
    //     create a uniformly random unit vector in 5D space,
    //     then step along it with the cauchy distribution.
    // To generate the first part we use a normal distribution for each dimension
    // then normalize it then scale it.
    // The normalization factor and the cauchy scale can be computed centrally
    // such that we avoid redoing it in each texel of PlanetBuffer1.
    // We have to be careful to use the same time seed when calculating this scale as when using it.
    float total_gaussian_length_squared = 0;
    for (int i=0; i<2*PLANET_COUNT; ++i) {
        vec4 g = gaussian_pixel(ivec2(universe, i), time);
        total_gaussian_length_squared += dot(g, g);
    }
    return cauchy_sample_1(
        hash21(vec2(universe, time)),
        0,
        temperature
    ) / sqrt(total_gaussian_length_squared);
}


vec4 new_planet(vec2 pos, float time) {
    // Structure of PlanetBufferX:
    // One column per universe.
    // On the first half the pixels in each column:
    //   R: Planet.a.x
    //   G: Planet.a.y
    //   B: Planet.b.x
    //   A: Planet.b.y
    // and in the second half:
    //   R: Planet.r
    //   G: Unused
    //   B: Unused
    //   A: Unused
    if (pos.y < .5) {
        return hash34(vec3(pos, time)) * 2 - 1;
    } else {
        return vec4(hash31(vec3(pos, time)) * .5, 0, 0, 1);
    }
}
vec4 initial_planets(vec2 pos) {
    return new_planet(pos, 0);
}
vec4 initial_evolution_vars(ivec2 pos) {
    // Structure of the `evolution_vars` pixel
    // R: animation theta (time based but modulo'd for accuracy)
    // G: time elapsed
    // B: temperature
    // A: time elapse of the previous frame
    return vec4(0, 1, 0, -TIMESTEP);
}
vec4 initial_choice(ivec2 pos) {
    // Structure of the `BufferChoice` pixel
    // R: whether we should use the new planets from buffer1.
    // G: Unused
    // B: Unused
    // A: Unused
    return vec4(0, 0, 1, 1);
}
float initial_rng_scale(ivec2 pos) {
    return rng_scale_implementation(pos.x, -TIMESTEP);
}

float cost_function(Planet[PLANET_COUNT] planets) {
    float[PLANET_COUNT] total_overlaps = get_total_overlaps(planets);
    float total_overlap = 0;
    float total_radius = 0;
    float total_apogee = 0;
    float total_ecentricity = 0;
    for (int i=0; i<PLANET_COUNT; ++i) {
        total_overlap += total_overlaps[i];
        total_radius += sqrt(planets[i].r);
        // float apogee = length(planets[i].a) + length(planets[i].b);
        // total_apogee += pow(max(0, apogee-0.5), 2);
        float la = length(planets[i].a);
        float lb = length(planets[i].b);
        total_apogee += la + lb;
        total_ecentricity += max(la, lb) - min(la, lb);
    }
    // total_radius = 0;
    return (
        0
        + weight_overlap * total_overlap
        + weight_apogee * total_apogee
        - weight_radius * total_radius
        + weight_ecentricity * total_ecentricity
    );
}

feedback RngScale, PlanetBuffer1, PlanetBuffer2, PlanetBuffer3, BufferChoice, EvolutionVars, UniverseRender {

    Planet[PLANET_COUNT] get_planets(sampler2D planet_buffer, int universe) {
        Planet[PLANET_COUNT] planets;
        for (int i=0; i<PLANET_COUNT; ++i) {
            vec4 ab = texelFetch(planet_buffer, ivec2(universe, i), 0);
            float r = texelFetch(planet_buffer, ivec2(universe, i+PLANET_COUNT), 0).r;
            planets[i] = Planet(ab.xy, ab.zw, r);
        }
        return planets;
    }
    float get_time() {            return texelFetch(EvolutionVars, ivec2(0), 0).r;    }
    float get_animation_theta() { return texelFetch(EvolutionVars, ivec2(0), 0).g;    }
    float get_temperature() {     return texelFetch(EvolutionVars, ivec2(0), 0).b;    }
    float get_prev_time() {       return texelFetch(EvolutionVars, ivec2(0), 0).a;    }

    float rng_scale(ivec2 pos) {
        return rng_scale_implementation(pos.x, get_prev_time());
    }

    vec4 planet_buffer1(ivec2 pos) {
        vec4 random_sample = texelFetch(RngScale, ivec2(pos.x, 0), 0).r * gaussian_pixel(pos, get_time());
        // if (pos.y >= PLANET_COUNT) random_sample.a = 1;
        vec4 prev = texelFetch(PlanetBuffer3, pos, 0);
        return prev + random_sample;
    }
    vec4 planet_buffer2(ivec2 pos) {
        return texelFetch(PlanetBuffer1, pos, 0);
    }
    vec4 planet_buffer3(ivec2 pos) {
        vec4 p2 = texelFetch(PlanetBuffer2, pos, 0);
        vec4 p3 = texelFetch(PlanetBuffer3, pos, 0);
        // if (pos.x%2 == 1) {
        //     return texelFetch(BufferChoice, ivec2(pos.x, 0), 0);
        // }
        return mix(p3, p2, texelFetch(BufferChoice, ivec2(pos.x, 0), 0).r);
        // return texelFetch(use_new? PlanetBuffer2 : PlanetBuffer3, pos, 0);
    }

    vec4 buffer_choice(ivec2 pos) {
        float cost1 = cost_function(get_planets(PlanetBuffer1, pos.x));
        float cost3 = cost_function(get_planets(PlanetBuffer3, pos.x));
        // TODO: randomly accept or not.
        return vec4((cost1 < cost3)? 1 : 0, 0, 0, 1);
    }

    vec4 evolution_vars(ivec2 pos) {
        vec4 evars = texelFetch(EvolutionVars, pos, 0);
        evars.r = mod(evars.r + TIMESTEP, TAU);
        evars.g = evars.g + TIMESTEP;
        evars.b = 1;
        evars.a = evars.g;
        return evars;
    }


    vec3 universe_render(vec2 pos) {
        // transform into a -1,-1  to 1,1 coordinate system
        pos -= .5;
        pos *= 2;
        float time = get_time();

        Planet[PLANET_COUNT] planets = get_planets(PlanetBuffer3, universe_select);
        float[PLANET_COUNT] total_overlaps = get_total_overlaps(planets);

        Planet zero = Planet(vec2(0), vec2(0), .005);
        vec3 col = planet_stencil(zero, pos, time) * white;
        for (int i=0; i<PLANET_COUNT; ++i) {
            float overlap = total_overlaps[i];
            col += planet_stencil(planets[i], pos, time) * vec3(overlap, .5, overlap <= 0? 1:0);
        }

        // planet_stencil(diff, pos, time) * red +
        // is_overlap_time(p1, p2, time) * red +
        col += float(printValue(cost_function(planets), ivec2(pos*100))) * lime;
        return exposure(col);
    }

    RngScale = glsl(rng_scale, UNIVERSE_COUNT, 1) : initialize(initial_rng_scale), full_range(true);
    PlanetBuffer1 = glsl(planet_buffer1, UNIVERSE_COUNT, 2*PLANET_COUNT) : initialize(initial_planets), full_range(true);
    PlanetBuffer2 = glsl(planet_buffer2, UNIVERSE_COUNT, 2*PLANET_COUNT) : initialize(initial_planets), full_range(true);
    PlanetBuffer3 = glsl(planet_buffer3, UNIVERSE_COUNT, 2*PLANET_COUNT) : initialize(initial_planets), full_range(true);
    BufferChoice = glsl(buffer_choice, UNIVERSE_COUNT, 1) : initialize(initial_choice), full_range(true);
    EvolutionVars = glsl(evolution_vars, 2, 2) : initialize(initial_evolution_vars), full_range(true);
    UniverseRender = glsl(universe_render, 512, 512);
} : update_rate(FPS), filter(nearest);


// animation Output = glsl(universe_render, 512, 512);
//export png_sequence(Output, "frames/????.png", 30, 1);
