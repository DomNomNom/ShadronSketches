#version 330

#include <hsv.shadron>
#include <debug.shadron>
#include "library/complexNumbers.shadron"
#include "library/murmurHash.shadron"

#define PLANET_COUNT 10
#define UNIVERSE_COUNT 100

#define FPS 60.0

param int universe_select : range(0, UNIVERSE_COUNT);
param float temperature = .1 : logrange(1e-15, .5);

glsl vec3 orange = vec3(1,.5,.0);
glsl vec3 lime = vec3(.5,1,.0);
glsl vec3 white = vec3(1,1,1);
glsl vec3 red = vec3(1,.1,.0);

struct Planet {
    vec2 a;
    vec2 b;
    float r;
};
vec2 planet_pos(Planet p, float time) {
    return cmul(p.a, ei(time)) + cmul(p.b, ei(-time));
}
float planet_stencil(Planet p, vec2 pos, float time) {
    vec2 ppos = planet_pos(p, time);
    const float boundary_size = .002;
    return smoothstep(boundary_size, -boundary_size, length(pos - ppos) - p.r);
}

Planet planet_orthoginalize(Planet p) {
    float arg_a = complex_arg(p.a);
    float arg_b = complex_arg(p.b);
    float average = (arg_a + arg_b)/2;
    return Planet(
        complex_rotate(p.a, -average),
        complex_rotate(p.b, -average),
        p.r
    );
}
Planet planet_unphase(Planet p) {
    return Planet(
        complex_rotate(p.a, -complex_arg(p.a)),
        complex_rotate(p.b, -complex_arg(p.b)),
        p.r
    );
}
Planet planet_standardize(Planet p) {
    return Planet(
        vec2(length(p.a), 0),
        vec2(length(p.b), 0),
        p.r
    );
}
vec2 planet_major_minor_lengths(Planet p) {
    float a = length(p.a);  // The unrotated and unphased versions of `a`
    float b = length(p.b);  // and `b` are purely real and preserve length.
    return vec2(a+b, a-b);  // What we evaluate to at t=0 and t=TAU/4
}

vec3 exposure(vec3 col) {
    return vec3(1) - pow(vec3(2), -1.8 * col);
}

float is_overlap_time(Planet p1, Planet p2, float time) {
    Planet p = Planet(p1.a - p2.a, p1.b - p2.b, p1.r + p2.r);
    float a = length(p.a);  // The unrotated and unphased versions of `a`
    float b = length(p.b);  // and `b` are purely real and preserve length.
    if (a*b <= 1e-15) return float(max(a,b) < p.r);
    float determinant = (p.r*p.r - a*a -b*b) / (2*a*b);
    if (determinant < -1) return 0;
    if (determinant > 1) return 1;
    float critical_angle = .5 * acos(determinant);
    time += (complex_arg(p.a) - complex_arg(p.b))/2;  // start caring about relative phases again.
    time = mod(time,PI);
    if (time > TAU / 4) time = PI - time;
    if (time - critical_angle > 0) return 1;
    return 0;
}

float overlap_fraction(Planet p1, Planet p2) {
    float a = length(p1.a - p2.a);  // The unrotated and unphased versions of `a`
    float b = length(p1.b - p2.b);  // and `b` are purely real and preserve length.
    float r = p1.r + p2.r;
    if (min(a,b) <= 1e-15) return float(max(a,b) < r);
    float determinant = (r*r - a*a -b*b) / (2*a*b);
    if (determinant <= -1) return 0;
    if (determinant >= 1) return 1;
    float critical_angle = .5 * acos(determinant);
    return 1 - (critical_angle / (TAU/4));
}
float[PLANET_COUNT] get_total_overlaps(Planet[PLANET_COUNT] planets) {
    float[PLANET_COUNT] total_overlaps;
    for (int i=0; i<PLANET_COUNT; ++i) {
        total_overlaps[i] = 0;
    }
    for (int i=0; i<PLANET_COUNT; ++i) {
        for (int j=i+1; j<PLANET_COUNT; ++j) {
            float overlap = overlap_fraction(planets[i], planets[j]);
            total_overlaps[i] += overlap;
            total_overlaps[j] += overlap;
        }
    }
    return total_overlaps;
}


vec4 new_planet(vec2 pos, float time) {
    // Structure of PlanetBufferX:
    // One column per universe.
    // On the first half the pixels in each column:
    //   R: Planet.a.x
    //   G: Planet.a.y
    //   B: Planet.b.x
    //   A: Planet.b.y
    // and in the second half:
    //   R: Planet.r
    //   G: Unused
    //   B: Unused
    //   A: Unused
    if (pos.y < .5) {
        return hash34(vec3(pos, time)) * 2 - 1;
    } else {
        return vec4(hash31(vec3(pos, time)) * .5, 0, 0, 1);
    }
}
vec4 initial_planets(vec2 pos) {
    return new_planet(pos, 0);
}
vec4 initial_evolution_vars(ivec2 pos) {
    // Structure of the `evolution_vars` pixel
    // R: time elapsed
    // G: temperature
    // B: Unused
    // A: Unused
    return vec4(0, 1, 0, 1);
}
vec4 initial_choice(ivec2 pos) {
    // Structure of the `BufferChoice` pixel
    // R: whether we should use the new planets from buffer1.
    // G: Unused
    // B: Unused
    // A: Unused
    return vec4(0, 0, 1, 1);
}

float cost_function(in Planet[PLANET_COUNT] planets) {
    float[PLANET_COUNT] total_overlaps = get_total_overlaps(planets);
    float total_overlap = 0;
    float total_radius = 0;
    float excess_apogee = 0;
    for (int i=0; i<PLANET_COUNT; ++i) total_overlap += total_overlaps[i];
    for (int i=0; i<PLANET_COUNT; ++i) total_radius += planets[i].r;
    for (int i=0; i<PLANET_COUNT; ++i) {
        float apogee = length(planets[i].a) + length(planets[i].b);
        excess_apogee = max(0, apogee-1);
    }
    return 1000*total_overlap + 10*excess_apogee - total_radius;
}

feedback PlanetBuffer, EvolutionVars, UniverseRender {
    Planet[PLANET_COUNT] get_planets(sampler2D planet_buffer, int universe) {
        Planet[PLANET_COUNT] planets;
        for (int i=0; i<PLANET_COUNT; ++i) {
            vec4 ab = texelFetch(planet_buffer, ivec2(universe, i), 0);
            float r = texelFetch(planet_buffer, ivec2(universe, i+PLANET_COUNT), 0).r;
            planets[i] = Planet(ab.xy, ab.zw, r);
        }
        return planets;
    }
    float get_time() {
        return texelFetch(EvolutionVars, ivec2(0), 0).r;
    }


    vec4 planet_buffer(ivec2 pos) {
        float time = get_time();
        Planet[PLANET_COUNT] planets = get_planets(PlanetBuffer, pos.x);
        float cost_old = cost_function(planets);
        for (int i=0; i<PLANET_COUNT; ++i) {
            vec4 ab = hash34(vec3(pos.x, pos.y * 2 + 0, time)) * 2 - 1;
            float r = hash31(vec3(pos.x, pos.y * 2 + 1, time)) * .5;
            planets[i%10] = Planet(ab.xy, ab.zw, r);
        }
        float cost_new = cost_function(planets);
        bool use_new = cost_new < cost_old;
        use_new = true;

        if (use_new) {
            Planet p = planets[pos.y % PLANET_COUNT];
            if (pos.y < PLANET_COUNT) {
                return vec4(p.a, p.b);
            } else {
                return vec4(p.r, cost_new / 200000., 0, 1);
            }
        } else {
            return texelFetch(PlanetBuffer, pos, 0);
        }
    }

    vec4 evolution_vars(ivec2 pos) {
        vec4 evars = texelFetch(EvolutionVars, pos, 0);
        evars.r = mod(evars.r + 1./FPS, TAU);
        // evars.r = 1;
        // evars.a = 1;
        // evars.g = 1;
        return evars;
    }


    vec3 universe_render(vec2 pos) {
        // transform into a -1,-1  to 1,1 coordinate system
        pos -= .5;
        pos *= 2;
        float time = get_time();

        Planet[PLANET_COUNT] planets = get_planets(PlanetBuffer, universe_select);
        float[PLANET_COUNT] total_overlaps = get_total_overlaps(planets);

        Planet zero = Planet(vec2(0), vec2(0), .005);
        vec3 col = planet_stencil(zero, pos, time) * white;
        for (int i=0; i<PLANET_COUNT; ++i) {
            float overlap = total_overlaps[i];
            col += planet_stencil(planets[i], pos, time) * vec3(overlap, .5, overlap <= 0? 1:0);
        }

        // planet_stencil(diff, pos, time) * red +
        // is_overlap_time(p1, p2, time) * red +
        col += float(printValue(cost_function(planets), ivec2(pos*100))) * lime;
        return exposure(col);
    }

    PlanetBuffer = glsl(planet_buffer, UNIVERSE_COUNT, 2*PLANET_COUNT) : initialize(initial_planets), full_range(true);
    EvolutionVars = glsl(evolution_vars, 2, 2) : initialize(initial_evolution_vars), full_range(true);
    UniverseRender = glsl(universe_render, 512, 512);
} : update_rate(FPS), filter(nearest);


// animation Output = glsl(universe_render, 512, 512);
//export png_sequence(Output, "frames/????.png", 30, 1);
