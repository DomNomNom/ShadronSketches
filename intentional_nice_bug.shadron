#version 330

#include <hsv.shadron>
#include <debug.shadron>
#include "library/complexNumbers.shadron"
#include "library/murmurHash.shadron"

#define PLANET_COUNT 10
#define UNIVERSE_COUNT 100

#define FPS 60.0

param int universe_select : range(0, UNIVERSE_COUNT);

glsl vec3 orange = vec3(1,.5,.0);
glsl vec3 lime = vec3(.5,1,.0);
glsl vec3 white = vec3(1,1,1);
glsl vec3 red = vec3(1,.1,.0);

struct Planet {
    vec2 a;
    vec2 b;
    float r;
};
vec2 planet_pos(Planet p, float time) {
    return cmul(p.a, ei(time)) + cmul(p.b, ei(-time));
}
float planet_stencil(Planet p, vec2 pos, float time) {
    vec2 ppos = planet_pos(p, time);
    const float boundary_size = .002;
    return smoothstep(boundary_size, -boundary_size, length(pos - ppos) - p.r);
}

Planet planet_orthoginalize(Planet p) {
    float arg_a = complex_arg(p.a);
    float arg_b = complex_arg(p.b);
    float average = (arg_a + arg_b)/2;
    return Planet(
        complex_rotate(p.a, -average),
        complex_rotate(p.b, -average),
        p.r
    );
}
Planet planet_unphase(Planet p) {
    return Planet(
        complex_rotate(p.a, -complex_arg(p.a)),
        complex_rotate(p.b, -complex_arg(p.b)),
        p.r
    );
}
Planet planet_standardize(Planet p) {
    return Planet(
        vec2(length(p.a), 0),
        vec2(length(p.b), 0),
        p.r
    );
}
vec2 planet_major_minor_lengths(Planet p) {
    float a = length(p.a);  // The unrotated and unphased versions of `a`
    float b = length(p.b);  // and `b` are purely real and preserve length.
    return vec2(a+b, a-b);  // What we evaluate to at t=0 and t=TAU/4
}

vec3 exposure(vec3 col) {
    return vec3(1) - pow(vec3(2), -1.8 * col);
}

float is_overlap_time(Planet p1, Planet p2, float time) {
    Planet p = Planet(p1.a - p2.a, p1.b - p2.b, p1.r + p2.r);
    float a = length(p.a);  // The unrotated and unphased versions of `a`
    float b = length(p.b);  // and `b` are purely real and preserve length.
    if (a*b <= 1e-15) return float(max(a,b) < p.r);
    float determinant = (p.r*p.r - a*a -b*b) / (2*a*b);
    if (determinant < -1) return 0;
    if (determinant > 1) return 1;
    float critical_angle = .5 * acos(determinant);
    time += (complex_arg(p.a) - complex_arg(p.b))/2;  // start caring about relative phases again.
    time = mod(time,PI);
    if (time > TAU / 4) time = PI - time;
    if (time - critical_angle > 0) return 1;
    return 0;
}

float overlap_fraction(Planet p1, Planet p2) {
    float a = length(p1.a - p2.a);  // The unrotated and unphased versions of `a`
    float b = length(p1.b - p2.b);  // and `b` are purely real and preserve length.
    float r = p1.r + p2.r;
    if (min(a,b) <= 1e-15) return float(max(a,b) < r);
    float determinant = (r*r - a*a -b*b) / (2*a*b);
    if (determinant <= -1) return 0;
    if (determinant >= 1) return 1;
    float critical_angle = .5 * acos(determinant);
    return 1 - (critical_angle / (TAU/4));
}
float[PLANET_COUNT] get_total_overlaps(Planet[PLANET_COUNT] planets) {
    float[PLANET_COUNT] total_overlaps;
    for (int i=0; i<PLANET_COUNT; ++i) {
        total_overlaps[i] = 0;
    }
    for (int i=0; i<PLANET_COUNT; ++i) {
        for (int j=i+1; j<PLANET_COUNT; ++j) {
            float overlap = overlap_fraction(planets[i], planets[j]);
            total_overlaps[i] += overlap;
            total_overlaps[j] += overlap;
        }
    }
    return total_overlaps;
}



vec4 initial_AB(vec2 pos) {
    return hash24(pos) * 2 - 1;
}
float initial_R(vec2 pos) {
    return hash21(pos) * .5;
}
vec4 initial_evolution_vars(ivec2 pos) {
    // Structure of the `evolution_vars` pixel
    // R: time elapsed
    // G: temperature
    // B: Unused
    // A: Unused
    return vec4(0, 1, 0, 1);
}

float cost_function(in Planet[PLANET_COUNT] planets) {
    float[PLANET_COUNT] total_overlaps = get_total_overlaps(planets);
    float total_overlap = 0;
    float total_radius = 0;
    float excess_apogee = 0;
    for (int i=0; i<PLANET_COUNT; ++i) total_overlap += total_overlaps[i];
    for (int i=0; i<PLANET_COUNT; ++i) total_radius += planets[i].r;
    for (int i=0; i<PLANET_COUNT; ++i) {
        float apogee = length(planets[i].a) + length(planets[i].b);
        excess_apogee = max(0, apogee-1);
    }
    return 1000*total_overlap + 10*excess_apogee - total_radius;
}

feedback Planet_ABs, Planet_Rs, EvolutionVars, UniverseRender {
    Planet[PLANET_COUNT] get_planets(int universe) {
        Planet[PLANET_COUNT] planets;
        for (int i=0; i<PLANET_COUNT; ++i) {
            vec4 ab = texelFetch(Planet_ABs, ivec2(universe, i), 0);
            float r = texelFetch(Planet_Rs, ivec2(universe, i), 0).r;
            planets[i] = Planet(ab.xy, ab.zw, r);
        }
        return planets;
    }
    Planet[PLANET_COUNT] get_new_planets(int universe, vec2 pos) {
        float time = texelFetch(EvolutionVars, ivec2(0), 0).r;

        Planet[PLANET_COUNT] planets;
        for (int i=0; i<PLANET_COUNT; ++i) {
            vec4 ab = murmurHash44(vec4(pos, universe, i*2));
            float r = murmurHash41(vec4(pos, universe, i*2+1));
            planets[i] = Planet(ab.xy, ab.zw, r);
        }
        return planets;
    }
    vec4 planet_AB(ivec2 pos) {
        return texelFetch(Planet_ABs, pos, 0);
    }
    Planet_ABs = glsl(planet_AB, UNIVERSE_COUNT, PLANET_COUNT) : initialize(initial_AB), full_range(true);

    float planet_R(ivec2 pos) {
        return texelFetch(Planet_Rs, pos, 0).r;
    }
    Planet_Rs = glsl(planet_R, UNIVERSE_COUNT, PLANET_COUNT) : initialize(initial_R), full_range(true);

    vec4 evolution_vars(ivec2 pos) {
        vec4 evars = texelFetch(EvolutionVars, pos, 0);
        evars.r = mod(evars.r + 1./FPS, TAU);
        // evars.r = 1;
        // evars.a = 1;
        // evars.g = 1;
        return evars;
    }
    EvolutionVars = glsl(evolution_vars, 2, 2) : initialize(initial_evolution_vars), full_range(true);


    vec3 universe_render(vec2 pos) {
        // transform into a -1,-1  to 1,1 coordinate system
        pos -= .5;
        pos *= 2;
        float time = texelFetch(EvolutionVars, ivec2(0), 0).r;

        Planet[PLANET_COUNT] planets = get_planets(universe_select);
        float[PLANET_COUNT] total_overlaps = get_total_overlaps(planets);

        Planet zero = Planet(vec2(0), vec2(0), .005);
        vec3 col = planet_stencil(zero, pos, time) * white;
        for (int i=0; i<PLANET_COUNT; ++i) {
            float overlap = total_overlaps[i];
            col += planet_stencil(planets[i], pos, time) * vec3(overlap, .5, overlap <= 0? 1:0);
        }

        // planet_stencil(diff, pos, time) * red +
        // is_overlap_time(p1, p2, time) * red +
        col += float(printValue(cost_function(planets), ivec2(pos*100))) * lime;
        return exposure(col);
    }
    UniverseRender = glsl(universe_render, 512, 512);

} : update_rate(FPS), filter(nearest);


// animation Output = glsl(universe_render, 512, 512);
//export png_sequence(Output, "frames/????.png", 30, 1);
