#version 330

#include <hsv.shadron>
#include <debug.shadron>
#include "library/complexNumbers.shadron"
#include "library/murmurHash.shadron"

#define PLANET_COUNT 10
#define UNIVERSE_COUNT 100

#define FPS 144.0

param int universe_select : range(0, UNIVERSE_COUNT);
param float temperature = .1 : logrange(1e-15, .5);

glsl vec3 orange = vec3(1,.5,.0);
glsl vec3 lime = vec3(.5,1,.0);
glsl vec3 white = vec3(1,1,1);
glsl vec3 red = vec3(1,.1,.0);

struct Planet {
    vec2 a;
    vec2 b;
    float r;
};
vec2 planet_pos(Planet p, float time) {
    return cmul(p.a, ei(time)) + cmul(p.b, ei(-time));
}
float planet_stencil(Planet p, vec2 pos, float time) {
    vec2 ppos = planet_pos(p, time);
    const float boundary_size = .002;
    return smoothstep(boundary_size, -boundary_size, length(pos - ppos) - p.r);
}

Planet planet_orthoginalize(Planet p) {
    float arg_a = complex_arg(p.a);
    float arg_b = complex_arg(p.b);
    float average = (arg_a + arg_b)/2;
    return Planet(
        complex_rotate(p.a, -average),
        complex_rotate(p.b, -average),
        p.r
    );
}
Planet planet_unphase(Planet p) {
    return Planet(
        complex_rotate(p.a, -complex_arg(p.a)),
        complex_rotate(p.b, -complex_arg(p.b)),
        p.r
    );
}
Planet planet_standardize(Planet p) {
    return Planet(
        vec2(length(p.a), 0),
        vec2(length(p.b), 0),
        p.r
    );
}
vec2 planet_major_minor_lengths(Planet p) {
    float a = length(p.a);  // The unrotated and unphased versions of `a`
    float b = length(p.b);  // and `b` are purely real and preserve length.
    return vec2(a+b, a-b);  // What we evaluate to at t=0 and t=TAU/4
}

vec3 exposure(vec3 col) {
    return vec3(1) - pow(vec3(2), -1.8 * col);
}

float is_overlap_time(Planet p1, Planet p2, float time) {
    Planet p = Planet(p1.a - p2.a, p1.b - p2.b, p1.r + p2.r);
    float a = length(p.a);  // The unrotated and unphased versions of `a`
    float b = length(p.b);  // and `b` are purely real and preserve length.
    if (a*b <= 1e-15) return float(max(a,b) < p.r);
    float determinant = (p.r*p.r - a*a -b*b) / (2*a*b);
    if (determinant < -1) return 0;
    if (determinant > 1) return 1;
    float critical_angle = .5 * acos(determinant);
    time += (complex_arg(p.a) - complex_arg(p.b))/2;  // start caring about relative phases again.
    time = mod(time,PI);
    if (time > TAU / 4) time = PI - time;
    if (time - critical_angle > 0) return 1;
    return 0;
}

float overlap_fraction(Planet p1, Planet p2) {
    float a = length(p1.a - p2.a);  // The unrotated and unphased versions of `a`
    float b = length(p1.b - p2.b);  // and `b` are purely real and preserve length.
    float r = p1.r + p2.r;
    if (min(a,b) <= 1e-15) return float(max(a,b) < r);
    float determinant = (r*r - a*a -b*b) / (2*a*b);
    if (determinant <= -1) return 0;
    if (determinant >= 1) return 1;
    float critical_angle = .5 * acos(determinant);
    return 1 - (critical_angle / (TAU/4));
}
float[PLANET_COUNT] get_total_overlaps(Planet[PLANET_COUNT] planets) {
    float[PLANET_COUNT] total_overlaps;
    for (int i=0; i<PLANET_COUNT; ++i) {
        total_overlaps[i] = 0;
    }
    for (int i=0; i<PLANET_COUNT; ++i) {
        for (int j=i+1; j<PLANET_COUNT; ++j) {
            float overlap = overlap_fraction(planets[i], planets[j]);
            total_overlaps[i] += overlap;
            total_overlaps[j] += overlap;
        }
    }
    return total_overlaps;
}

float cauchy_sample(float random_zero_to_one, float median, float scale) {
    return median + scale * tan(PI*(random_zero_to_one-0.5));
}
vec4 cauchy_sample_4(vec4 random_zero_to_one, vec4 median, float scale) {
    return median + scale * tan(PI*(random_zero_to_one-0.5));
}

vec4 new_planet(vec2 pos, float time) {
    // Structure of PlanetBufferX:
    // One column per universe.
    // On the first half the pixels in each column:
    //   R: Planet.a.x
    //   G: Planet.a.y
    //   B: Planet.b.x
    //   A: Planet.b.y
    // and in the second half:
    //   R: Planet.r
    //   G: Unused
    //   B: Unused
    //   A: Unused
    if (pos.y < .5) {
        return hash34(vec3(pos, time)) * 2 - 1;
    } else {
        return vec4(hash31(vec3(pos, time)) * .5, 0, 0, 1);
    }
}
vec4 initial_planets(vec2 pos) {
    return new_planet(pos, 0);
}
vec4 initial_evolution_vars(ivec2 pos) {
    // Structure of the `evolution_vars` pixel
    // R: theta (time based but modulo'd for accuracy)
    // G: time elapsed
    // B: temperature
    // A: Unused
    return vec4(0, 1, 0, 1);
}
vec4 initial_choice(ivec2 pos) {
    // Structure of the `BufferChoice` pixel
    // R: whether we should use the new planets from buffer1.
    // G: Unused
    // B: Unused
    // A: Unused
    return vec4(0, 0, 1, 1);
}

float cost_function(Planet[PLANET_COUNT] planets) {
    float[PLANET_COUNT] total_overlaps = get_total_overlaps(planets);
    float total_overlap = 0;
    float total_radius = 0;
    float total_apogee = 0;
    float total_ecentricity = 0;
    for (int i=0; i<PLANET_COUNT; ++i) {
        total_overlap += total_overlaps[i];
        total_radius += sqrt(planets[i].r);
        // float apogee = length(planets[i].a) + length(planets[i].b);
        // total_apogee += pow(max(0, apogee-0.5), 2);
        float la = length(planets[i].a);
        float lb = length(planets[i].b);
        total_apogee += la + lb;
        total_ecentricity += max(la, lb) - min(la, lb);
    }
    // total_radius = 0;
    return 1000*total_overlap + 10*total_apogee - total_radius + 10*total_ecentricity;
}

feedback PlanetBuffer1, PlanetBuffer2, PlanetBuffer3, BufferChoice, EvolutionVars, UniverseRender {
    Planet[PLANET_COUNT] get_planets(sampler2D planet_buffer, int universe) {
        Planet[PLANET_COUNT] planets;
        for (int i=0; i<PLANET_COUNT; ++i) {
            vec4 ab = texelFetch(planet_buffer, ivec2(universe, i), 0);
            float r = texelFetch(planet_buffer, ivec2(universe, i+PLANET_COUNT), 0).r;
            planets[i] = Planet(ab.xy, ab.zw, r);
        }
        return planets;
    }
    float get_time() {
        return texelFetch(EvolutionVars, ivec2(0), 0).r;
    }
    float get_temperature() {
        return texelFetch(EvolutionVars, ivec2(0), 0).r;
    }

    vec4 planet_buffer1(ivec2 pos) {

        vec4 prev = texelFetch(PlanetBuffer3, pos, 0);
        float time = get_time();
        if (pos.y < PLANET_COUNT) {
            return cauchy_sample_4(
                hash34(vec3(pos, time)),
                prev,
                temperature
            );
        } else {
            float r = max(
                1e-3,
                cauchy_sample(
                    hash31(vec3(pos, time)),
                    prev.r,
                    .1*temperature
                )
            );
            return vec4(r, 0, 0, 1);
        }
    }
    vec4 planet_buffer2(ivec2 pos) {
        return texelFetch(PlanetBuffer1, pos, 0);
    }
    vec4 planet_buffer3(ivec2 pos) {
        vec4 p2 = texelFetch(PlanetBuffer2, pos, 0);
        vec4 p3 = texelFetch(PlanetBuffer3, pos, 0);
        // if (pos.x%2 == 1) {
        //     return texelFetch(BufferChoice, ivec2(pos.x, 0), 0);
        // }
        return mix(p3, p2, texelFetch(BufferChoice, ivec2(pos.x, 0), 0).r);
        // return texelFetch(use_new? PlanetBuffer2 : PlanetBuffer3, pos, 0);
    }

    vec4 buffer_choice(ivec2 pos) {
        float cost1 = cost_function(get_planets(PlanetBuffer1, pos.x));
        float cost3 = cost_function(get_planets(PlanetBuffer3, pos.x));
        // TODO: randomly accept or not.
        return vec4((cost1 < cost3)? 1 : 0, 0, 0, 1);
    }

    vec4 evolution_vars(ivec2 pos) {
        vec4 evars = texelFetch(EvolutionVars, pos, 0);
        evars.r = mod(evars.r + 1./FPS, TAU);
        // evars.r = 1;
        // evars.a = 1;
        // evars.g = 1;
        return evars;
    }


    vec3 universe_render(vec2 pos) {
        // transform into a -1,-1  to 1,1 coordinate system
        pos -= .5;
        pos *= 2;
        float time = get_time();

        Planet[PLANET_COUNT] planets = get_planets(PlanetBuffer3, universe_select);
        float[PLANET_COUNT] total_overlaps = get_total_overlaps(planets);

        Planet zero = Planet(vec2(0), vec2(0), .005);
        vec3 col = planet_stencil(zero, pos, time) * white;
        for (int i=0; i<PLANET_COUNT; ++i) {
            float overlap = total_overlaps[i];
            col += planet_stencil(planets[i], pos, time) * vec3(overlap, .5, overlap <= 0? 1:0);
        }

        // planet_stencil(diff, pos, time) * red +
        // is_overlap_time(p1, p2, time) * red +
        col += float(printValue(cost_function(planets), ivec2(pos*100))) * lime;
        return exposure(col);
    }

    PlanetBuffer1 = glsl(planet_buffer1, UNIVERSE_COUNT, 2*PLANET_COUNT) : initialize(initial_planets), full_range(true);
    PlanetBuffer2 = glsl(planet_buffer2, UNIVERSE_COUNT, 2*PLANET_COUNT) : initialize(initial_planets), full_range(true);
    PlanetBuffer3 = glsl(planet_buffer3, UNIVERSE_COUNT, 2*PLANET_COUNT) : initialize(initial_planets), full_range(true);
    BufferChoice = glsl(buffer_choice, UNIVERSE_COUNT, 1) : initialize(initial_choice), full_range(true);
    EvolutionVars = glsl(evolution_vars, 2, 2) : initialize(initial_evolution_vars), full_range(true);
    UniverseRender = glsl(universe_render, 512, 512);
} : update_rate(FPS), filter(nearest);


// animation Output = glsl(universe_render, 512, 512);
//export png_sequence(Output, "frames/????.png", 30, 1);
