#include <hsv.shadron>
#include "library/complexNumbers.shadron"

parameter vec2 A = vec2(.75*ROOT2/2, .75*ROOT2/2);
parameter vec2 B = vec2(-.25*ROOT2/2, .25*ROOT2/2);
parameter vec2 C = vec2(.75, 0);
parameter vec2 D = vec2(.25, 0);

glsl vec3 orange = vec3(1,.5,.0);
glsl vec3 lime = vec3(.5,1,.0);
glsl vec3 white = vec3(1,1,1);
glsl vec3 red = vec3(1,.1,.0);

struct Planet {
    vec2 a;
    vec2 b;
    float r;
};
vec2 planet_pos(Planet p, float time) {
    return cmul(p.a, ei(time)) + cmul(p.b, ei(-time));
}
float planet_stencil(Planet p, vec2 pos, float time) {
    vec2 ppos = planet_pos(p, time);
    const float boundary_size = .002;
    return smoothstep(boundary_size, -boundary_size, length(pos - ppos) - p.r);
}

Planet planet_orthoginalize(Planet p) {
    float arg_a = complex_arg(p.a);
    float arg_b = complex_arg(p.b);
    float average = (arg_a + arg_b)/2;
    return Planet(
        complex_rotate(p.a, -average),
        complex_rotate(p.b, -average),
        p.r
    );
}
Planet planet_unphase(Planet p) {
    float arg_a = complex_arg(p.a);
    float arg_b = complex_arg(p.b);
    return Planet(
        complex_rotate(p.a, -arg_a),
        complex_rotate(p.b, -arg_b),
        p.r
    );
}
Planet planet_standardize(Planet p) {
    return Planet(
        vec2(length(p.a), 0),
        vec2(length(p.b), 0),
        p.r
    );
}

vec3 intentional_nice_bug(vec2 pos, float time) {
    // transform into a -1,-1  to 1,1 coordinate system
    pos -= .5;
    pos *= 2;

    Planet p1 = planet_unphase(planet_orthoginalize(Planet(A, B, .1)));
    Planet p2 = Planet(C, D, .1);
    p2 = planet_standardize(Planet(A, B, .1));
    Planet zero = Planet(vec2(0), vec2(0), .005);
    Planet diff = planet_orthoginalize(Planet(p1.a - p2.a, p1.b - p2.b, p1.r + p2.r));
    return (
        planet_stencil(p1, pos, time) * orange +
        planet_stencil(p2, pos, time) * lime +
        planet_stencil(zero, pos, time) * white +
        // planet_stencil(diff, pos, time) * red +
        0
    );
}


animation Output = glsl(intentional_nice_bug, 512, 512);
//export png_sequence(Output, "frames/????.png", 30, 1);
