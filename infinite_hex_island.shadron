#include <math_constants>
#include <multisample>


// param float fuck = sqrt(3) : range(ROOT3);
param vec3 back_color = .1*vec3(1) : color;
param vec3 edge_color = .5*vec3(1, .5, 0) : color;
param vec3 node_color = .8*vec3(1, .5, 0) : color;
param vec3 king_color = .6*vec3(.5, .2, .7) : color;
param float edge_wd = .05;
param float node_r = .1;
param float king_r = .2;

param float fisheyeness = .1;
param float grid_scale = 1.5;

// Hexagon constants. btw, this is neat: https://hexagoncalculator.apphb.com/
glsl const float sidelength = (2/3.) * sqrt(3);
glsl const float halfside = sidelength/2.;

// note: "sd" refers to signed distance functions. https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm
param float sd_smoothness = .001 : range(0, .05);
glsl float sdHexagon(in vec2 p, in float r) {
    const vec3 k = vec3(-0.866025404, 0.5, 0.577350269);
    p = abs(p);
    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;
    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);
    return length(p)*sign(p.y);
}

// https://www.desmos.com/calculator/ysahugtxt7/*  */
glsl float pause_step(float x, float a, float b) {
    float g = min(a, mod(x, a+b));
    float f = a * floor(x / (a+b));
    return g + f;
}

glsl vec2 fisheye(vec2 pos) {
    // return pos * tan(length(pos)*TAU/4) / fisheyeness;
    // return pos * (1/(1-length(pos))-1) / fisheyeness;
    return normalize(pos) * (1 / (1-length(pos)) - 1);
}
glsl vec2 fisheye_inverse(vec2 pos) {
    float y = length(pos);
    return normalize(pos) * (y/(y+1));
}

glsl vec2 path_pos(float node_distance) {
    vec2 king_pos = vec2(-halfside, 1);
    king_pos.x += pause_step(node_distance, sidelength, sidelength);
    king_pos += vec2(cos(TAU/6), sin(TAU/6)) * pause_step(node_distance-sidelength, sidelength, sidelength);
    return king_pos;
}

glsl vec4 render(vec2 pos, float time) {
    pos = (pos - .5) * 2;

    float node_distance = (time - (1/(3.*TAU))*sin(time*2*TAU))*(2*sidelength);
    vec2 king_pos = path_pos(node_distance);

    float dist_to_next_cycle = min(.5,distance(fisheye(king_pos), fisheye(path_pos(node_distance + 2*sidelength))));

    pos *= 5 * dist_to_next_cycle;
    float sd = length(pos) - (king_r * dist_to_next_cycle);
    vec4 king = vec4(king_color, smoothstep(sd_smoothness*dist_to_next_cycle, -sd_smoothness*dist_to_next_cycle, sd));

    vec2 camera_center = fisheye_inverse(king_pos);
    pos += camera_center;
    if (length(pos) > 1) return vec4(back_color, 1);
    // pos += fisheye(king_pos);
    pos = fisheye(pos);


    // float sd = distance(pos, king_pos) - king_r;

    // Repeat along rectangular sections.
    pos = mod(pos, vec2(2*ROOT3, 2));

    // Fold along some lines to not have to draw as many shapes.
    pos -= vec2(ROOT3, 1);
    pos = -abs(pos);
    pos += vec2(ROOT3, 1);

    // Add edges by rendering negative Hexagons
    sd = 99999999999.;
    float hex_r = 1-.5*edge_wd;
    sd = min(sd, sdHexagon(pos-vec2(0,0), hex_r));
    // sd = min(sd, sdHexagon(pos-vec2(0,2), hex_r));
    sd = min(sd, sdHexagon(pos-vec2(ROOT3, 1), hex_r));
    // sd = min(sd, sdHexagon(pos-vec2(2*ROOT3,0), hex_r));
    // sd = min(sd, sdHexagon(pos-vec2(2*ROOT3,2), hex_r));
    vec4 edge = vec4(edge_color, smoothstep(-sd_smoothness, sd_smoothness, sd));

    // Add nodes by add
    sd = 99999999999.;
    sd = min(sd, distance(pos, vec2(halfside, 1)) - node_r);
    sd = min(sd, distance(pos, vec2(ROOT3-halfside,0)) - node_r);
    vec4 node = vec4(node_color, smoothstep(sd_smoothness, -sd_smoothness, sd));

    vec4 col = vec4(back_color, 1);
    col.rgb = mix(col.rgb, edge.rgb, edge.a);
    col.rgb = mix(col.rgb, node.rgb, node.a);
    col.rgb = mix(col.rgb, king.rgb, king.a);
    return col;
}

animation Output = glsl(multisampleAnimation<render, 8, 1>, 800, 800);
export png_sequence(Output, "frames/????.png", 30, 10);
