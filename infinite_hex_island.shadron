#include <math_constants>
#include <multisample>


// param float fuck = sqrt(3) : range(ROOT3);
param vec3 back_color = .1*vec3(1) : color;
param vec3 edge_color = .5*vec3(1, .5, 0) : color;
param vec3 node_color = .8*vec3(1, .5, 0) : color;
param vec3 king_color = .6*vec3(.5, .2, .7) : color;
param float edge_wd = .05;
param float node_r = .1;
param float king_r = .2;

param float fisheyeness = .2;

// Hexagon constants. btw, this is neat: https://hexagoncalculator.apphb.com/
glsl const float sidelength = (2/3.) * sqrt(3);
glsl const float halfside = sidelength/2.;

// note: "sd" refers to signed distance functions. https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm
param float sd_smoothness = .001 : range(0, .05);
glsl float sdHexagon(in vec2 p, in float r) {
    const vec3 k = vec3(-0.866025404, 0.5, 0.577350269);
    p = abs(p);
    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;
    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);
    return length(p)*sign(p.y);
}

// https://www.desmos.com/calculator/ysahugtxt7/*  */
glsl float pause_step(float x, float a, float b) {
    float g = min(a, mod(x, a+b));
    float f = a * floor(x / (a+b));
    return g + f;
}

glsl vec4 render(vec2 pos, float time) {
    pos = (pos - .5) * 2;
    if (length(pos) > 1) return vec4(back_color, 1);

    float distance_travelled = (time - (1/(3.*TAU))*sin(time*2*TAU))*(2*sidelength);
    // distance_travelled += sidelength*cos(distance_travelled*TAU);
    vec2 king_pos = vec2(-halfside, 1);
    king_pos.x += pause_step(distance_travelled, sidelength, sidelength);
    king_pos += vec2(cos(TAU/6), sin(TAU/6)) * pause_step(distance_travelled-sidelength, sidelength, sidelength);


    pos *= tan(pow(length(pos), fisheyeness)*TAU/4);
    pos *= 1.5;
    pos += king_pos;


    float sd = distance(pos, king_pos) - king_r;
    vec4 king = vec4(king_color, smoothstep(sd_smoothness, -sd_smoothness, sd));

    // Repeat along rectangular sections.
    pos = mod(pos, vec2(2*ROOT3, 2));

    // Fold along some lines to not have to draw as many shapes.
    pos -= vec2(ROOT3, 1);
    pos = -abs(pos);
    pos += vec2(ROOT3, 1);

    // Add edges by rendering negative Hexagons
    sd = 99999999999.;
    float hex_r = 1-.5*edge_wd;
    sd = min(sd, sdHexagon(pos-vec2(0,0), hex_r));
    // sd = min(sd, sdHexagon(pos-vec2(0,2), hex_r));
    sd = min(sd, sdHexagon(pos-vec2(ROOT3, 1), hex_r));
    // sd = min(sd, sdHexagon(pos-vec2(2*ROOT3,0), hex_r));
    // sd = min(sd, sdHexagon(pos-vec2(2*ROOT3,2), hex_r));
    vec4 edge = vec4(edge_color, smoothstep(-sd_smoothness, sd_smoothness, sd));

    // Add nodes by add
    sd = 99999999999.;
    sd = min(sd, distance(pos, vec2(halfside, 1)) - node_r);
    sd = min(sd, distance(pos, vec2(ROOT3-halfside,0)) - node_r);
    vec4 node = vec4(node_color, smoothstep(sd_smoothness, -sd_smoothness, sd));

    vec4 col = vec4(back_color, 1);
    col.rgb = mix(col.rgb, edge.rgb, edge.a);
    col.rgb = mix(col.rgb, node.rgb, node.a);
    col.rgb = mix(col.rgb, king.rgb, king.a);
    return col;
}

animation Output = glsl(multisampleAnimation<render, 8, 1>, 1300, 1300);
export png_sequence(Output, "frames/????.png", 30, 1);
